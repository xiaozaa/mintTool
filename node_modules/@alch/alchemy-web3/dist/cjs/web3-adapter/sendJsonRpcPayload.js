"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeJsonRpcPayloadSender = void 0;
var tslib_1 = require("tslib");
var assert_never_1 = tslib_1.__importDefault(require("assert-never"));
var promises_1 = require("../util/promises");
var ALCHEMY_DISALLOWED_METHODS = [
    "eth_accounts",
    "eth_sendTransaction",
    "eth_sign",
    "eth_signTypedData_v3",
    "eth_signTypedData",
    "personal_sign",
];
function makeJsonRpcPayloadSender(alchemySendJsonRpc, config) {
    var currentWriteProvider = config.writeProvider;
    var sendJsonRpcPayload = function (payload) {
        var disallowedMethod = getDisallowedMethod(payload);
        if (!disallowedMethod) {
            try {
                return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);
            }
            catch (alchemyError) {
                // Fallback to write provider, but if both fail throw the error from
                // Alchemy.
                if (!currentWriteProvider) {
                    throw alchemyError;
                }
                try {
                    return sendJsonRpcWithProvider(currentWriteProvider, payload);
                }
                catch (_a) {
                    throw alchemyError;
                }
            }
        }
        else {
            if (!currentWriteProvider) {
                throw new Error("No provider available for method \"" + disallowedMethod + "\"");
            }
            return sendJsonRpcWithProvider(currentWriteProvider, payload);
        }
    };
    function setWriteProvider(writeProvider) {
        currentWriteProvider = writeProvider !== null && writeProvider !== void 0 ? writeProvider : null;
    }
    return {
        sendJsonRpcPayload: sendJsonRpcPayload,
        setWriteProvider: setWriteProvider,
    };
}
exports.makeJsonRpcPayloadSender = makeJsonRpcPayloadSender;
function sendJsonRpcWithProvider(provider, payload) {
    var anyProvider = provider;
    var sendMethod = (anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send).bind(anyProvider);
    return promises_1.promisify(function (callback) { return sendMethod(payload, callback); });
}
function getDisallowedMethod(payload) {
    var payloads = Array.isArray(payload) ? payload : [payload];
    var disallowedRequest = payloads.find(function (p) { return ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0; }) ||
        undefined;
    return disallowedRequest && disallowedRequest.method;
}
function sendJsonRpcWithRetries(payload, alchemySendJsonRpc, _a) {
    var maxRetries = _a.maxRetries, retryInterval = _a.retryInterval, retryJitter = _a.retryJitter;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var i, result, status_1, message, statusString;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    i = 0;
                    _b.label = 1;
                case 1:
                    if (!(i < maxRetries + 1)) return [3 /*break*/, 5];
                    return [4 /*yield*/, alchemySendJsonRpc(payload)];
                case 2:
                    result = _b.sent();
                    switch (result.type) {
                        case "jsonrpc":
                            return [2 /*return*/, result.response];
                        case "rateLimit":
                            break;
                        case "networkError": {
                            status_1 = result.status, message = result.message;
                            statusString = status_1 !== 0 ? "(" + status_1 + ") " : "";
                            throw new Error(statusString + " " + message);
                        }
                        default:
                            return [2 /*return*/, assert_never_1.default(result)];
                    }
                    return [4 /*yield*/, promises_1.delay(retryInterval + ((retryJitter * Math.random()) | 0))];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    i++;
                    return [3 /*break*/, 1];
                case 5: throw new Error("Rate limited for " + (maxRetries + 1) + " consecutive attempts.");
            }
        });
    });
}
