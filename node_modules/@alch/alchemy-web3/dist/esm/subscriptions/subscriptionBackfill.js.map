{"version":3,"file":"subscriptionBackfill.js","sourceRoot":"","sources":["../../../src/subscriptions/subscriptionBackfill.ts"],"names":[],"mappings":"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","sourcesContent":["import { fromHex, toHex } from \"../util/hex\";\nimport { BatchPart, JsonRpcSenders } from \"../util/jsonRpc\";\nimport { throwIfCancelled } from \"../util/promises\";\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/**\n * The return type of eth_getBlocksByHash.\n */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\ninterface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\nexport type Backfiller = ReturnType<typeof makeBackfiller>;\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\nexport function makeBackfiller(jsonRpcSenders: JsonRpcSenders) {\n  return { getNewHeadsBackfill, getLogsBackfill };\n\n  async function getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number,\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousHeads.length === 0) {\n      return getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n    const reorgHeads: NewHeadsEvent[] = await getReorgHeads(\n      isCancelled,\n      previousHeads,\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  async function getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  async function getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: \"eth_getBlockByNumber\",\n        params: [toHex(i), false],\n      });\n    }\n    const heads = await jsonRpcSenders.sendBatch(batchParts);\n    return heads.map(toNewHeadsEvent);\n  }\n\n  async function getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return jsonRpcSenders.send(\"eth_getBlockByNumber\", [\n      toHex(blockNumber),\n      false,\n    ]);\n  }\n\n  async function getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number,\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousLogs.length === 0) {\n      return getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n    const commonAncestorNumber = await getCommonAncestorNumber(\n      isCancelled,\n      previousLogs,\n    );\n    throwIfCancelled(isCancelled);\n    const removedLogs = previousLogs\n      .filter((log) => fromHex(log.blockNumber) > commonAncestorNumber)\n      .map((log) => ({ ...log, removed: true }));\n    const addedLogs = await getLogsInRange(\n      filter,\n      commonAncestorNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  async function getCommonAncestorNumber(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[],\n  ): Promise<number> {\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const { blockHash, blockNumber } = previousLogs[i];\n      const { hash } = await getBlockByNumber(fromHex(blockNumber));\n      throwIfCancelled(isCancelled);\n      if (blockHash === hash) {\n        return fromHex(blockNumber);\n      }\n    }\n    return Number.NEGATIVE_INFINITY;\n  }\n\n  async function getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1),\n    };\n    return jsonRpcSenders.send(\"eth_getLogs\", [rangeFilter]);\n  }\n\n  async function getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await jsonRpcSenders.send(\"eth_blockNumber\");\n    return fromHex(blockNumberHex);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, (event) => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, (event) => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach((item) => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n"]}